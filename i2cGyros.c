/*
 * Copyright (c) 2018-2023, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

///*
// *  ======== i2ctmp.c ========
// */
//#include <stdint.h>
//#include <stddef.h>
//#include <unistd.h>
//
///* Driver Header files */
//#include <ti/drivers/GPIO.h>/*This header file provides functions to control General-Purpose Input/Output (GPIO) pins.*/
//#include <ti/drivers/I2C.h>/*This header file provides functions to communicate with I2C (Inter-Integrated Circuit) devices.*/
//
//
///* Driver configuration, includes a board-specific driver configuration file that is automatically generated by TI's SysConfig tool in Code Composer Studio (CCS).*/
//#include "ti_drivers_config.h"
//
//#define TASKSTACKSIZE 640 /* we can check for the requiered memory size*/
//
///* Temperature result registers */
//
////FATIMAH
//#define MPU6050_I2C_ADDR  0x68  // Default I2C address of MPU6050In I2C communication, each device has a unique address.The master (microcontroller)
////communicates with a specific slave device using this address.
////The MPU6050's default I2C address is 0x68 (hexadecimal). AD0 on the sensor connected to the ground of the chip
//#define MPU6050_TEMP_OUT_H 0x41 // Temperature high byte register
//#define MPU6050_TEMP_OUT_L 0x42 // Temperature low byte register
//
//
//
///*
// * Data structure containing currently supported I2C TMP sensors.
// * Sensors are ordered by descending preference.
// */
//
////FATIMAH
//static const struct
//{
//    uint8_t address;
//    uint8_t resultReg;
//    char *id;
//} sensor = {MPU6050_I2C_ADDR, MPU6050_TEMP_OUT_H, "MPU6050"}; /*The low register (0x42) is not included because we
// read both high and low bytes in a single I2C transaction, making it unnecessary to store 0x42 separately. */
//static uint8_t targetAddress;
//
//static void i2cErrorHandler(I2C_Transaction *transaction);
//
///*
// *  ======== mainThread ========
// */
//
////FATIMAH
//
//void *mainThread(void *arg0)
//{
//    uint16_t sample; // Keeps track of temperature readings.
//    int16_t rawTemp; // Stores raw 16-bit temperature data.
//    float temperature; // Stores final temperature in Celsius.
//
//    uint8_t txBuffer[1] = {MPU6050_TEMP_OUT_H}; // Register to request temperature
//    uint8_t rxBuffer[2]; // Stores high & low bytes of temperature data
//
//    I2C_Handle i2c;
//    I2C_Params i2cParams;
//    I2C_Transaction i2cTransaction;
//
//    /* Initialize Drivers */
//    GPIO_init();
//    I2C_init();
//
//    /* Configure LED */
//    GPIO_setConfig(CONFIG_GPIO_LED_0, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);
//    GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_ON);
//
//    printf("Starting MPU6050 Temperature Example\n");
//
//    /* Initialize I2C */
//    I2C_Params_init(&i2cParams);
//    i2cParams.bitRate = I2C_400kHz; // Set I2C speed to 400 kHz
//    i2c = I2C_open(CONFIG_I2C_TMP, &i2cParams);
//
//    if (i2c == NULL)
//    {
//        printf("Error Initializing I2C\n");
//        return NULL;
//    }
//
//    printf("I2C Initialized! Reading temperature...\n");
//
//    /* Setup I2C transaction for reading MPU6050 temperature */
//    i2cTransaction.targetAddress = MPU6050_I2C_ADDR;
//    i2cTransaction.writeBuf = txBuffer;  // Send register address (0x41)
//    i2cTransaction.writeCount = 1;
//    i2cTransaction.readBuf = rxBuffer;  // Read 2 bytes (high + low)
//    i2cTransaction.readCount = 2;
//
//    /* Take 20 samples and print them out onto the console */
//    for (sample = 0; sample < 20; sample++)
//    {
//        /* Step 1: Write register address (0x41) to MPU6050 */
//        i2cTransaction.writeBuf = txBuffer;
//        i2cTransaction.writeCount = 1;
//        i2cTransaction.readBuf = NULL;
//        i2cTransaction.readCount = 0;
//
//        if (!I2C_transfer(i2c, &i2cTransaction))
//        {
//            printf("Error: Failed to write to MPU6050\n");
//            break;
//        }
//
//        /* Step 2: Read temperature data from MPU6050 */
//        i2cTransaction.writeBuf = NULL;
//        i2cTransaction.writeCount = 0;
//        i2cTransaction.readBuf = rxBuffer;
//        i2cTransaction.readCount = 2;
//
//        if (!I2C_transfer(i2c, &i2cTransaction))
//        {
//            printf("Error: Failed to read from MPU6050\n");
//            break;
//        }
//
//        /* Convert temperature data */
//        rawTemp = (rxBuffer[0] << 8) | rxBuffer[1];  // Combine high and low bytes
//        temperature = (rawTemp / 340.0) + 36.53;  // Convert to Celsius
//
//        printf("Sample %u: %.2f °C\n", sample, temperature);
//
//        /* Sleep for 1 second */
//        sleep(1);
//    }
//
//    I2C_close(i2c);
//    printf("I2C closed!\n");
//
//    return NULL;
//}
//
//
//static void i2cErrorHandler(I2C_Transaction *transaction)
//{
//    switch (transaction->status)
//    {
//        case I2C_STATUS_TIMEOUT:
//            printf("[ERROR] I2C transaction timed out!\n");
//            break;
//        case I2C_STATUS_CLOCK_TIMEOUT:
//            printf("[ERROR] I2C clock line timed out!\n");
//            break;
//        case I2C_STATUS_ADDR_NACK:
//            printf("[ERROR] I2C target address 0x%X not acknowledged!\n", transaction->targetAddress);
//            break;
//        case I2C_STATUS_DATA_NACK:
//            printf("[ERROR] I2C data byte not acknowledged!\n");
//            break;
//        case I2C_STATUS_ARB_LOST:
//            printf("[ERROR] I2C arbitration lost to another controller!\n");
//            break;
//        case I2C_STATUS_INCOMPLETE:
//            printf("[ERROR] I2C transaction returned before completion!\n");
//            break;
//        case I2C_STATUS_BUS_BUSY:
//            printf("[ERROR] I2C bus is already in use!\n");
//            break;
//        case I2C_STATUS_CANCEL:
//            printf("[ERROR] I2C transaction was cancelled!\n");
//            break;
//        case I2C_STATUS_INVALID_TRANS:
//            printf("[ERROR] I2C transaction invalid!\n");
//            break;
//        case I2C_STATUS_ERROR:
//            printf("[ERROR] General I2C error occurred!\n");
//            break;
//        default:
//            printf("[ERROR] Undefined I2C error!\n");
//            break;
//    }
//}
#include <stdint.h>
#include <stddef.h>
#include <unistd.h>
#include <stdio.h>
#include <ti/drivers/GPIO.h>
#include <ti/drivers/I2C.h>
#include "ti_drivers_config.h"

#define MPU6050_I2C_ADDR  0x68  // Try 0x69 if needed
#define MPU6050_PWR_MGMT_1  0x6B  // Power management register
#define MPU6050_GYRO_XOUT_H  0x43  // Gyro X high byte

#define GYRO_SENSITIVITY 131.0  // Default ±250°/s

void *mainThread(void *arg0)
{
    int16_t rawGyroX, rawGyroY, rawGyroZ;
    float gyroX, gyroY, gyroZ;
    uint8_t txBuffer[1] = {MPU6050_GYRO_XOUT_H};
    uint8_t rxBuffer[6];

    I2C_Handle i2c;
    I2C_Params i2cParams;
    I2C_Transaction i2cTransaction;

    /* Initialize Drivers */
    GPIO_init();
    I2C_init();

    /* Initialize I2C */
    I2C_Params_init(&i2cParams);
    i2cParams.bitRate = I2C_400kHz;
    i2c = I2C_open(CONFIG_I2C_TMP, &i2cParams);

    if (i2c == NULL)
    {
        printf("Error Initializing I2C\n");
        return NULL;
    }

    /* Wake Up MPU6050 */
    uint8_t wakeUpCmd[2] = {MPU6050_PWR_MGMT_1, 0x00};
    i2cTransaction.targetAddress = MPU6050_I2C_ADDR;
    i2cTransaction.writeBuf = wakeUpCmd;
    i2cTransaction.writeCount = 2;
    i2cTransaction.readBuf = NULL;
    i2cTransaction.readCount = 0;

    if (!I2C_transfer(i2c, &i2cTransaction))
    {
        printf("Error: Failed to wake up MPU6050\n");
        return NULL;
    }
    printf("MPU6050 is now awake!\n");

    /* Read Gyroscope Data */
    for (int sample = 0; sample < 30; sample++)
    {
        i2cTransaction.writeBuf = txBuffer;
        i2cTransaction.writeCount = 1;
        i2cTransaction.readBuf = rxBuffer;
        i2cTransaction.readCount = 6;

        if (!I2C_transfer(i2c, &i2cTransaction))
        {
            printf("Error: Failed to read from MPU6050\n");
            break;
        }

        /* Convert raw values to degrees per second */
        rawGyroX = (rxBuffer[0] << 8) | rxBuffer[1];
        rawGyroY = (rxBuffer[2] << 8) | rxBuffer[3];
        rawGyroZ = (rxBuffer[4] << 8) | rxBuffer[5];

        gyroX = rawGyroX / GYRO_SENSITIVITY;
        gyroY = rawGyroY / GYRO_SENSITIVITY;
        gyroZ = rawGyroZ / GYRO_SENSITIVITY;

        printf("Sample %d: Gyro X: %.2f dps, Gyro Y: %.2f dps, Gyro Z: %.2f dps\n",
               sample, gyroX, gyroY, gyroZ);

        sleep(1);
    }

    I2C_close(i2c);
    printf("I2C closed!\n");
    return NULL;
}
